##codegen.jl
# functions relating to verilog code generation and verilation.

function normalized_key(mod::Union{Function, Symbol}, p::Tuple)
  m_rep = Symbol(mod)

  for k in keys(__global_dependency_cache)
    if (k[1] == Symbol(mod)) && ([p...] == [pair.second for pair in k[2:end]])
      return k
    end
  end

  throw(ArgumentError("Key not found!"))
end

doc"""
  `Verilog.find_dependencies(mod, (params...))`

  outputs the set of dependencies of a certain module.
"""
@generated function find_dependencies(mod, p::Tuple, exclude = [])
  if mod <: Function  #then it's a "manual call"
    tuplegen = :(key = normalized_key(mod, p))
  elseif mod == Symbol
    tuplegen = :(key = (mod, p...))
  else
    throw(ArgumentError("module type unsupported: $mod"))
  end

  quote
    $tuplegen
    deps = __global_dependency_cache[key]

    result = Tuple[]
    #now iterate through the dependencies.

    for d in deps
      if !((d in result) || (d in exclude))
        unshift!(result, d)
        result = union(result, find_dependencies(d[1], d[2:end]))
      end
    end
    result
  end
end

const lintoff_stmts = """
/* verilator lint_off DECLFILENAME */
/* verilator lint_off UNUSED */

"""

doc"""
  `generate_verilog_file(path, mod, (params...); exclude = [])`

  pass this function a path, (verilog module) name and the parameters, and it
  puts that module and its dependencies into a file in the desired path.  The
  filename will be (module name + suffix).v, with module name & suffix as
  generated by the interal specifications.
"""
function generate_verilog_file(path::String, mod::Function, p::Tuple; exclude = [])
  #test to see if the path exists.
  isdir(path) || mkdir(path)
  #first call the function and make it.
  modulestring = mod(p...)
  modulename = ""

  #next call its dependencies.
  deps = find_dependencies(mod, p, exclude)
  depstrings = [__global_definition_cache[dep].txt for dep in deps]

  #next, retrieve the proper name for the file.
  nkey = normalized_key(mod, p)

  modulename = __global_definition_cache[nkey].module_name

  #next, create a file for the header.
  vfile_fio = open(string(path, "/", modulename, ".v"), "w")
  try
    #write the contents
    println(vfile_fio, lintoff_stmts)
    println(vfile_fio, join(depstrings, "\n\n"))
    println(vfile_fio, modulestring)
  finally
    #close the directory
    close(vfile_fio)
  end

  #return its dependencies so that we can keep track of all modules we've
  #created so far.
  unshift!(deps, nkey)
  deps
end

export generate_verilog_file


doc"""
  `verilate(mod::Function, p::Tuple; path::String)`
  uses verilator to create a .so file corresponding to the library.
  Each of the functions in the mods array will be the top-level element
  in a freestanding .v file.  They may refer to each other.
  the "mods" are a tuple of the function and the parameter.
"""
function verilate(mod::Function, p::Tuple; path::String = ".")
  #check to see if the path_to_c_library is actually a dir.
  isdir(path) || mkdir(path)

  nkey = normalized_key(mod, p)
  #retrieve the proper name of this function
  name = __global_definition_cache[nkey].module_name

  #create the temp directory
  mktempdir((tdir)->begin
    #create the interface cpp file.
    open((file) -> begin
      println(file, verilator_adapter(nkey))
    end, string(tdir, "/", name, "_interface.cpp"), "w")

    println("tdir:", tdir)
    generate_verilog_file(tdir, mod, p)

    #next move into the temporary directory and then
    cd(()->begin
      run(`verilator -Wall --cc -CFLAGS -fPIC $name.v --top-module $name --exe $(name)_interface.cpp`)
    end, tdir)

    cd(()-> begin
      #run the make file.  This will throw an error due to not finding a --main
      #but that's OK it just needs to make the object files.
      run(`make -f V$name.mk`)

      object_files = ["$tdir/obj_dir/$f" for f in readdir() if f[end-1:end] == ".o"]

      #manually link the object files into a shared library.
      run(`cc -Wall -shared $object_files -o libVerilated.so`)
    end, "$tdir/obj_dir")

    #finally, save the temporary verilated file into the main path, squashing it if necessary.
    mv("$tdir/obj_dir/libVerilated.so", "$path/libVerilated.so"; remove_destination=true)
  end)
end

macro vfunc(path...)
  if length(path) == 1
    path = path[1]
  else
    path = "./libVerilated.so"
  end

  esc(quote
    #go ahead and initalize it.
    ccall((:init, $path), Void, ())

    function veval(a::Unsigned)
      ccall((:set, $path), Void, (UInt64,), a)
      ccall((:step, $path), Void, ())
      ccall((:get, $path), UInt64, ())
    end
    function veval(a::Unsigned,b::Unsigned,c::Unsigned)
      ccall((:set, $path), Void, (UInt64, UInt64, UInt64), a, b, c)
      ccall((:step, $path), Void, ())
      ccall((:get, $path), UInt64, ())
    end
    function veval(a::Unsigned,b::Unsigned)
      ccall((:set, $path), Void, (UInt64, UInt64), a, b)
      ccall((:step, $path), Void, ())
      ccall((:get, $path), UInt64, ())
    end
  end)
end

export verilate
export @vfunc
